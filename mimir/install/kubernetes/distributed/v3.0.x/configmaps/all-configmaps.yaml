apiVersion: v1
items:
- apiVersion: v1
  data:
    alertmanager_fallback_config.yaml: |
      receivers:
          - name: default-receiver
      route:
          receiver: default-receiver
  kind: ConfigMap
  metadata:
    labels:
      app.kubernetes.io/component: alertmanager
      app.kubernetes.io/instance: mimir
      app.kubernetes.io/name: mimir
      app.kubernetes.io/part-of: memberlist
    name: mimir-alertmanager-fallback-config
    namespace: mimir-test
- apiVersion: v1
  data:
    mimir.yaml: |2

      activity_tracker:
        filepath: /active-query-tracker/activity.log
      alertmanager:
        data_dir: /data
        enable_api: true
        external_url: /alertmanager
        fallback_config_file: /configs/alertmanager_fallback_config.yaml
      alertmanager_storage:
        backend: s3
        s3:
          access_key_id: grafana-mimir
          bucket_name: mimir-ruler
          endpoint: mimir-minio.mimir-test.svc:9000
          insecure: true
          secret_access_key: supersecret
      blocks_storage:
        backend: s3
        bucket_store:
          sync_dir: /data/tsdb-sync
        s3:
          access_key_id: grafana-mimir
          bucket_name: mimir-tsdb
          endpoint: mimir-minio.mimir-test.svc:9000
          insecure: true
          secret_access_key: supersecret
        tsdb:
          dir: /data/tsdb
          head_compaction_interval: 15m
          wal_replay_concurrency: 3
      compactor:
        compaction_interval: 30m
        data_dir: /data
        deletion_delay: 2h
        first_level_compaction_wait_period: 25m
        max_closing_blocks_concurrency: 2
        max_opening_blocks_concurrency: 4
        sharding_ring:
          heartbeat_period: 1m
          heartbeat_timeout: 4m
          wait_stability_min_duration: 1m
        symbols_flushers_concurrency: 4
      distributor:
        remote_timeout: 5s
        ring:
          heartbeat_period: 1m
          heartbeat_timeout: 4m
      frontend:
        parallelize_shardable_queries: true
        scheduler_address: mimir-query-scheduler-headless.mimir-test.svc:9095
      frontend_worker:
        grpc_client_config:
          max_send_msg_size: 419430400
        scheduler_address: mimir-query-scheduler-headless.mimir-test.svc:9095
      ingest_storage:
        enabled: true
        kafka:
          address: mimir-kafka.mimir-test.svc.cluster.local.:9092
          auto_create_topic_default_partitions: 100
          auto_create_topic_enabled: true
          topic: mimir-ingest
      ingester:
        push_grpc_method_enabled: false
        ring:
          final_sleep: 0s
          heartbeat_period: 2m
          heartbeat_timeout: 10m
          num_tokens: 512
          tokens_file_path: /data/tokens
          unregister_on_shutdown: false
          zone_awareness_enabled: true
      ingester_client:
        grpc_client_config:
          max_recv_msg_size: 104857600
          max_send_msg_size: 104857600
      limits:
        max_cache_freshness: 10m
        max_query_parallelism: 240
        max_total_query_length: 12000h
      memberlist:
        abort_if_cluster_join_fails: false
        compression_enabled: false
        join_members:
        - dns+mimir-gossip-ring.mimir-test.svc.cluster.local.:7946
      querier:
        max_concurrent: 16
      query_scheduler:
        max_outstanding_requests_per_tenant: 800
      ruler:
        alertmanager_url: dnssrvnoa+http://_http-metrics._tcp.mimir-alertmanager-headless.mimir-test.svc.cluster.local./alertmanager
        enable_api: true
        rule_path: /data
      ruler_storage:
        backend: s3
        s3:
          access_key_id: grafana-mimir
          bucket_name: mimir-ruler
          endpoint: mimir-minio.mimir-test.svc:9000
          insecure: true
          secret_access_key: supersecret
      runtime_config:
        file: /var/mimir/runtime.yaml
      server:
        grpc_listen_port: 9095
        grpc_server_max_concurrent_streams: 1000
        http_listen_port: 8080
        log_level: warn
      store_gateway:
        sharding_ring:
          heartbeat_period: 1m
          heartbeat_timeout: 10m
          kvstore:
            prefix: multi-zone/
          tokens_file_path: /data/tokens
          unregister_on_shutdown: false
          wait_stability_min_duration: 1m
          zone_awareness_enabled: true
      usage_stats:
        enabled: false # default = true
        installation_mode: custom # Supported: custom, helm, jsonnet
  kind: ConfigMap
  metadata:
    labels:
      app.kubernetes.io/instance: mimir
      app.kubernetes.io/name: mimir
    name: mimir-config
    namespace: mimir-test
- apiVersion: v1
  data:
    nginx.conf: |
      worker_processes  5;  ## Default: 1
      error_log  /dev/stderr error;
      pid        /tmp/nginx.pid;
      worker_rlimit_nofile 8192;

      events {
        worker_connections  4096;  ## Default: 1024
      }

      http {
        client_body_temp_path /tmp/client_temp;
        proxy_temp_path       /tmp/proxy_temp_path;
        fastcgi_temp_path     /tmp/fastcgi_temp;
        uwsgi_temp_path       /tmp/uwsgi_temp;
        scgi_temp_path        /tmp/scgi_temp;

        default_type application/octet-stream;
        log_format   main '$remote_addr - $remote_user [$time_local]  $status '
              '"$request" $body_bytes_sent "$http_referer" '
              '"$http_user_agent" "$http_x_forwarded_for"';
        access_log   /dev/stderr  main;

        sendfile           on;
        tcp_nopush         on;
        proxy_http_version 1.1;
        resolver kube-dns.kube-system.svc.cluster.local.;

        # Ensure that X-Scope-OrgID is always present, default to the no_auth_tenant for backwards compatibility when multi-tenancy was turned off.
        map $http_x_scope_orgid $ensured_x_scope_orgid {
          default $http_x_scope_orgid;
          "" "anonymous";
        }

        map $http_x_scope_orgid $has_multiple_orgid_headers {
          default 0;
          "~^.+,.+$" 1;
        }

        proxy_read_timeout 300;
        server {
          listen 8080;
          listen [::]:8080;
          client_max_body_size 540M;

          if ($has_multiple_orgid_headers = 1) {
              return 400 'Sending multiple X-Scope-OrgID headers is not allowed. Use a single header with | as separator instead.';
          }

          location = / {
            return 200 'OK';
            auth_basic off;
          }

          location = /ready {
            return 200 'OK';
            auth_basic off;
          }

          proxy_set_header X-Scope-OrgID $ensured_x_scope_orgid;

          # Distributor endpoints
          location /distributor {
            set $distributor mimir-distributor-headless.mimir-test.svc.cluster.local.;
            proxy_pass      http://$distributor:8080$request_uri;
          }
          location = /api/v1/push {
            set $distributor mimir-distributor-headless.mimir-test.svc.cluster.local.;
            proxy_pass      http://$distributor:8080$request_uri;
          }
          location /otlp/v1/metrics {
            set $distributor mimir-distributor-headless.mimir-test.svc.cluster.local.;
            proxy_pass      http://$distributor:8080$request_uri;
          }

          # Alertmanager endpoints
          location /alertmanager {
            set $alertmanager mimir-alertmanager-headless.mimir-test.svc.cluster.local.;
            proxy_pass      http://$alertmanager:8080$request_uri;
          }
          location = /multitenant_alertmanager/status {
            set $alertmanager mimir-alertmanager-headless.mimir-test.svc.cluster.local.;
            proxy_pass      http://$alertmanager:8080$request_uri;
          }
          location = /multitenant_alertmanager/configs {
            set $alertmanager mimir-alertmanager-headless.mimir-test.svc.cluster.local.;
            proxy_pass      http://$alertmanager:8080$request_uri;
          }
          location = /api/v1/alerts {
            set $alertmanager mimir-alertmanager-headless.mimir-test.svc.cluster.local.;
            proxy_pass      http://$alertmanager:8080$request_uri;
          }

          # Ruler endpoints
          location /prometheus/config/v1/rules {
            set $ruler mimir-ruler.mimir-test.svc.cluster.local.;
            proxy_pass      http://$ruler:8080$request_uri;
          }
          location /prometheus/api/v1/rules {
            set $ruler mimir-ruler.mimir-test.svc.cluster.local.;
            proxy_pass      http://$ruler:8080$request_uri;
          }

          location /prometheus/api/v1/alerts {
            set $ruler mimir-ruler.mimir-test.svc.cluster.local.;
            proxy_pass      http://$ruler:8080$request_uri;
          }
          location = /ruler/ring {
            set $ruler mimir-ruler.mimir-test.svc.cluster.local.;
            proxy_pass      http://$ruler:8080$request_uri;
          }

          # Rest of /prometheus goes to the query frontend
          location /prometheus {
            set $query_frontend mimir-query-frontend.mimir-test.svc.cluster.local.;
            proxy_pass      http://$query_frontend:8080$request_uri;
          }

          # Buildinfo endpoint can go to any component
          location = /api/v1/status/buildinfo {
            set $query_frontend mimir-query-frontend.mimir-test.svc.cluster.local.;
            proxy_pass      http://$query_frontend:8080$request_uri;
          }

          # Compactor endpoint for uploading blocks
          location /api/v1/upload/block/ {
            set $compactor mimir-compactor.mimir-test.svc.cluster.local.;
            proxy_pass      http://$compactor:8080$request_uri;
          }
        }
      }
  kind: ConfigMap
  metadata:
    labels:
      app.kubernetes.io/component: gateway-nginx
      app.kubernetes.io/instance: mimir
      app.kubernetes.io/name: mimir
    name: mimir-gateway-nginx
    namespace: mimir-test
- apiVersion: v1
  data:
    add-policy: |-
      #!/bin/sh
      set -e ; # Have script exit in the event of a failed command.
      MC_CONFIG_DIR="/tmp/minio/mc/"
      MC="/usr/bin/mc --insecure --config-dir ${MC_CONFIG_DIR}"

      # connectToMinio
      # Use a check-sleep-check loop to wait for MinIO service to be available
      connectToMinio() {
        SCHEME=$1
        ATTEMPTS=0 ; LIMIT=29 ; # Allow 30 attempts
        set -e ; # fail if we can't read the keys.
        ACCESS=$(cat /config/rootUser) ; SECRET=$(cat /config/rootPassword) ;
        set +e ; # The connections to minio are allowed to fail.
        echo "Connecting to MinIO server: $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT" ;
        MC_COMMAND="${MC} alias set myminio $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT $ACCESS $SECRET" ;
        $MC_COMMAND ;
        STATUS=$? ;
        until [ $STATUS = 0 ]
        do
          ATTEMPTS=`expr $ATTEMPTS + 1` ;
          echo \"Failed attempts: $ATTEMPTS\" ;
          if [ $ATTEMPTS -gt $LIMIT ]; then
            exit 1 ;
          fi ;
          sleep 2 ; # 1 second intervals between attempts
          $MC_COMMAND ;
          STATUS=$? ;
        done ;
        set -e ; # reset `e` as active
        return 0
      }

      # checkPolicyExists ($policy)
      # Check if the policy exists, by using the exit code of `mc admin policy info`
      checkPolicyExists() {
        POLICY=$1
        CMD=$(${MC} admin policy info myminio $POLICY > /dev/null 2>&1)
        return $?
      }

      # createPolicy($name, $filename)
      createPolicy () {
        NAME=$1
        FILENAME=$2

        # Create the name if it does not exist
        echo "Checking policy: $NAME (in /config/$FILENAME.json)"
        if ! checkPolicyExists $NAME ; then
          echo "Creating policy '$NAME'"
        else
          echo "Policy '$NAME' already exists."
        fi
        ${MC} admin policy create myminio $NAME /config/$FILENAME.json

      }

      # Try connecting to MinIO instance
      scheme=http
      connectToMinio $scheme
    add-svcacct: |-
      #!/bin/sh
      set -e ; # Have script exit in the event of a failed command.
      MC_CONFIG_DIR="/tmp/minio/mc/"
      MC="/usr/bin/mc --insecure --config-dir ${MC_CONFIG_DIR}"

      # AccessKey and secretkey credentials file are added to prevent shell execution errors caused by special characters.
      # Special characters for example : ',",<,>,{,}
      MINIO_ACCESSKEY_SECRETKEY_TMP="/tmp/accessKey_and_secretKey_svcacct_tmp"

      # connectToMinio
      # Use a check-sleep-check loop to wait for MinIO service to be available
      connectToMinio() {
        SCHEME=$1
        ATTEMPTS=0 ; LIMIT=29 ; # Allow 30 attempts
        set -e ; # fail if we can't read the keys.
        ACCESS=$(cat /config/rootUser) ; SECRET=$(cat /config/rootPassword) ;
        set +e ; # The connections to minio are allowed to fail.
        echo "Connecting to MinIO server: $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT" ;
        MC_COMMAND="${MC} alias set myminio $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT $ACCESS $SECRET" ;
        $MC_COMMAND ;
        STATUS=$? ;
        until [ $STATUS = 0 ]
        do
          ATTEMPTS=`expr $ATTEMPTS + 1` ;
          echo \"Failed attempts: $ATTEMPTS\" ;
          if [ $ATTEMPTS -gt $LIMIT ]; then
            exit 1 ;
          fi ;
          sleep 2 ; # 2 second intervals between attempts
          $MC_COMMAND ;
          STATUS=$? ;
        done ;
        set -e ; # reset `e` as active
        return 0
      }

      # checkSvcacctExists ()
      # Check if the svcacct exists, by using the exit code of `mc admin user svcacct info`
      checkSvcacctExists() {
        CMD=$(${MC} admin user svcacct info myminio $(head -1 $MINIO_ACCESSKEY_SECRETKEY_TMP) > /dev/null 2>&1)
        return $?
      }

      # createSvcacct ($user)
      createSvcacct () {
        USER=$1
        FILENAME=$2
        #check accessKey_and_secretKey_tmp file
        if [[ ! -f $MINIO_ACCESSKEY_SECRETKEY_TMP ]];then
          echo "credentials file does not exist"
          return 1
        fi
        if [[ $(cat $MINIO_ACCESSKEY_SECRETKEY_TMP|wc -l) -ne 2 ]];then
          echo "credentials file is invalid"
          rm -f $MINIO_ACCESSKEY_SECRETKEY_TMP
          return 1
        fi
        SVCACCT=$(head -1 $MINIO_ACCESSKEY_SECRETKEY_TMP)
        # Create the svcacct if it does not exist
        if ! checkSvcacctExists ; then
          echo "Creating svcacct '$SVCACCT'"
          # Check if policy file is define
          if [ -z $FILENAME ]; then
            ${MC} admin user svcacct add --access-key $(head -1 $MINIO_ACCESSKEY_SECRETKEY_TMP) --secret-key $(tail -n1 $MINIO_ACCESSKEY_SECRETKEY_TMP) myminio $USER
          else
            ${MC} admin user svcacct add --access-key $(head -1 $MINIO_ACCESSKEY_SECRETKEY_TMP) --secret-key $(tail -n1 $MINIO_ACCESSKEY_SECRETKEY_TMP) --policy /config/$FILENAME.json myminio $USER
          fi
        else
          echo "Svcacct '$SVCACCT' already exists."
        fi
        #clean up credentials files.
        rm -f $MINIO_ACCESSKEY_SECRETKEY_TMP
      }

      # Try connecting to MinIO instance
      scheme=http
      connectToMinio $scheme
    add-user: |-
      #!/bin/sh
      set -e ; # Have script exit in the event of a failed command.
      MC_CONFIG_DIR="/tmp/minio/mc/"
      MC="/usr/bin/mc --insecure --config-dir ${MC_CONFIG_DIR}"

      # AccessKey and secretkey credentials file are added to prevent shell execution errors caused by special characters.
      # Special characters for example : ',",<,>,{,}
      MINIO_ACCESSKEY_SECRETKEY_TMP="/tmp/accessKey_and_secretKey_tmp"

      # connectToMinio
      # Use a check-sleep-check loop to wait for MinIO service to be available
      connectToMinio() {
        SCHEME=$1
        ATTEMPTS=0 ; LIMIT=29 ; # Allow 30 attempts
        set -e ; # fail if we can't read the keys.
        ACCESS=$(cat /config/rootUser) ; SECRET=$(cat /config/rootPassword) ;
        set +e ; # The connections to minio are allowed to fail.
        echo "Connecting to MinIO server: $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT" ;
        MC_COMMAND="${MC} alias set myminio $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT $ACCESS $SECRET" ;
        $MC_COMMAND ;
        STATUS=$? ;
        until [ $STATUS = 0 ]
        do
          ATTEMPTS=`expr $ATTEMPTS + 1` ;
          echo \"Failed attempts: $ATTEMPTS\" ;
          if [ $ATTEMPTS -gt $LIMIT ]; then
            exit 1 ;
          fi ;
          sleep 2 ; # 1 second intervals between attempts
          $MC_COMMAND ;
          STATUS=$? ;
        done ;
        set -e ; # reset `e` as active
        return 0
      }

      # checkUserExists ()
      # Check if the user exists, by using the exit code of `mc admin user info`
      checkUserExists() {
        CMD=$(${MC} admin user info myminio $(head -1 $MINIO_ACCESSKEY_SECRETKEY_TMP) > /dev/null 2>&1)
        return $?
      }

      # createUser ($policy)
      createUser() {
        POLICY=$1
        #check accessKey_and_secretKey_tmp file
        if [[ ! -f $MINIO_ACCESSKEY_SECRETKEY_TMP ]];then
          echo "credentials file does not exist"
          return 1
        fi
        if [[ $(cat $MINIO_ACCESSKEY_SECRETKEY_TMP|wc -l) -ne 2 ]];then
          echo "credentials file is invalid"
          rm -f $MINIO_ACCESSKEY_SECRETKEY_TMP
          return 1
        fi
        USER=$(head -1 $MINIO_ACCESSKEY_SECRETKEY_TMP)
        # Create the user if it does not exist
        if ! checkUserExists ; then
          echo "Creating user '$USER'"
          cat $MINIO_ACCESSKEY_SECRETKEY_TMP | ${MC} admin user add myminio
        else
          echo "User '$USER' already exists."
        fi
        #clean up credentials files.
        rm -f $MINIO_ACCESSKEY_SECRETKEY_TMP

        # set policy for user
        if [ ! -z $POLICY -a $POLICY != " " ] ; then
            echo "Adding policy '$POLICY' for '$USER'"
            set +e ; # policy already attach errors out, allow it.
            ${MC} admin policy attach myminio $POLICY --user=$USER
            set -e
        else
            echo "User '$USER' has no policy attached."
        fi
      }

      # Try connecting to MinIO instance
      scheme=http
      connectToMinio $scheme



      # Create the users
      echo console > $MINIO_ACCESSKEY_SECRETKEY_TMP
      echo console123 >> $MINIO_ACCESSKEY_SECRETKEY_TMP
      createUser consoleAdmin
    custom-command: |-
      #!/bin/sh
      set -e ; # Have script exit in the event of a failed command.
      MC_CONFIG_DIR="/tmp/minio/mc/"
      MC="/usr/bin/mc --insecure --config-dir ${MC_CONFIG_DIR}"

      # connectToMinio
      # Use a check-sleep-check loop to wait for MinIO service to be available
      connectToMinio() {
        SCHEME=$1
        ATTEMPTS=0 ; LIMIT=29 ; # Allow 30 attempts
        set -e ; # fail if we can't read the keys.
        ACCESS=$(cat /config/rootUser) ; SECRET=$(cat /config/rootPassword) ;
        set +e ; # The connections to minio are allowed to fail.
        echo "Connecting to MinIO server: $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT" ;
        MC_COMMAND="${MC} alias set myminio $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT $ACCESS $SECRET" ;
        $MC_COMMAND ;
        STATUS=$? ;
        until [ $STATUS = 0 ]
        do
          ATTEMPTS=`expr $ATTEMPTS + 1` ;
          echo \"Failed attempts: $ATTEMPTS\" ;
          if [ $ATTEMPTS -gt $LIMIT ]; then
            exit 1 ;
          fi ;
          sleep 2 ; # 1 second intervals between attempts
          $MC_COMMAND ;
          STATUS=$? ;
        done ;
        set -e ; # reset `e` as active
        return 0
      }

      # runCommand ($@)
      # Run custom mc command
      runCommand() {
        ${MC} "$@"
        return $?
      }

      # Try connecting to MinIO instance
      scheme=http
      connectToMinio $scheme
    initialize: "#!/bin/sh\nset -e # Have script exit in the event of a failed command.\nMC_CONFIG_DIR=\"/tmp/minio/mc/\"\nMC=\"/usr/bin/mc
      --insecure --config-dir ${MC_CONFIG_DIR}\"\n\n# connectToMinio\n# Use a check-sleep-check
      loop to wait for MinIO service to be available\nconnectToMinio() {\n\tSCHEME=$1\n\tATTEMPTS=0\n\tLIMIT=29
      # Allow 30 attempts\n\tset -e   # fail if we can't read the keys.\n\tACCESS=$(cat
      /config/rootUser)\n\tSECRET=$(cat /config/rootPassword)\n\tset +e # The connections
      to minio are allowed to fail.\n\techo \"Connecting to MinIO server: $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT\"\n\tMC_COMMAND=\"${MC}
      alias set myminio $SCHEME://$MINIO_ENDPOINT:$MINIO_PORT $ACCESS $SECRET\"\n\t$MC_COMMAND\n\tSTATUS=$?\n\tuntil
      [ $STATUS = 0 ]; do\n\t\tATTEMPTS=$(expr $ATTEMPTS + 1)\n\t\techo \\\"Failed
      attempts: $ATTEMPTS\\\"\n\t\tif [ $ATTEMPTS -gt $LIMIT ]; then\n\t\t\texit 1\n\t\tfi\n\t\tsleep
      2 # 1 second intervals between attempts\n\t\t$MC_COMMAND\n\t\tSTATUS=$?\n\tdone\n\tset
      -e # reset `e` as active\n\treturn 0\n}\n\n# checkBucketExists ($bucket)\n#
      Check if the bucket exists, by using the exit code of `mc ls`\ncheckBucketExists()
      {\n\tBUCKET=$1\n\tCMD=$(${MC} stat myminio/$BUCKET >/dev/null 2>&1)\n\treturn
      $?\n}\n\n# createBucket ($bucket, $policy, $purge)\n# Ensure bucket exists,
      purging if asked to\ncreateBucket() {\n\tBUCKET=$1\n\tPOLICY=$2\n\tPURGE=$3\n\tVERSIONING=$4\n\tOBJECTLOCKING=$5\n\n\t#
      Purge the bucket, if set & exists\n\t# Since PURGE is user input, check explicitly
      for `true`\n\tif [ $PURGE = true ]; then\n\t\tif checkBucketExists $BUCKET;
      then\n\t\t\techo \"Purging bucket '$BUCKET'.\"\n\t\t\tset +e # don't exit if
      this fails\n\t\t\t${MC} rm -r --force myminio/$BUCKET\n\t\t\tset -e # reset
      `e` as active\n\t\telse\n\t\t\techo \"Bucket '$BUCKET' does not exist, skipping
      purge.\"\n\t\tfi\n\tfi\n\n\t# Create the bucket if it does not exist and set
      objectlocking if enabled (NOTE: versioning will be not changed if OBJECTLOCKING
      is set because it enables versioning to the Buckets created)\n\tif ! checkBucketExists
      $BUCKET; then\n\t\tif [ ! -z $OBJECTLOCKING ]; then\n\t\t\tif [ $OBJECTLOCKING
      = true ]; then\n\t\t\t\techo \"Creating bucket with OBJECTLOCKING '$BUCKET'\"\n\t\t\t\t${MC}
      mb --with-lock myminio/$BUCKET\n\t\t\telif [ $OBJECTLOCKING = false ]; then\n\t\t\t\techo
      \"Creating bucket '$BUCKET'\"\n\t\t\t\t${MC} mb myminio/$BUCKET\n\t\t\tfi\n\t\telif
      [ -z $OBJECTLOCKING ]; then\n\t\t\techo \"Creating bucket '$BUCKET'\"\n\t\t\t${MC}
      mb myminio/$BUCKET\n\t\telse\n\t\t\techo \"Bucket '$BUCKET' already exists.\"\n\t\tfi\n\tfi\n\n\t#
      set versioning for bucket if objectlocking is disabled or not set\n\tif [ $OBJECTLOCKING
      = false ]; then\n\t\tif [ ! -z $VERSIONING ]; then\n\t\t\tif [ $VERSIONING =
      true ]; then\n\t\t\t\techo \"Enabling versioning for '$BUCKET'\"\n\t\t\t\t${MC}
      version enable myminio/$BUCKET\n\t\t\telif [ $VERSIONING = false ]; then\n\t\t\t\techo
      \"Suspending versioning for '$BUCKET'\"\n\t\t\t\t${MC} version suspend myminio/$BUCKET\n\t\t\tfi\n\t\tfi\n\telse\n\t\techo
      \"Bucket '$BUCKET' versioning unchanged.\"\n\tfi\n\n\t# At this point, the bucket
      should exist, skip checking for existence\n\t# Set policy on the bucket\n\techo
      \"Setting policy of bucket '$BUCKET' to '$POLICY'.\"\n\t${MC} anonymous set
      $POLICY myminio/$BUCKET\n}\n\n# Try connecting to MinIO instance\nscheme=http\nconnectToMinio
      $scheme\n\n\n\n# Create the buckets\ncreateBucket mimir-tsdb \"none\" false
      false false\ncreateBucket mimir-ruler \"none\" false false false"
  kind: ConfigMap
  metadata:
    labels:
      app: minio
    name: mimir-minio
    namespace: mimir-test
- apiVersion: v1
  data:
    runtime.yaml: |2

      {}
  kind: ConfigMap
  metadata:
    labels:
      app.kubernetes.io/instance: mimir
      app.kubernetes.io/name: mimir
    name: mimir-runtime
    namespace: mimir-test
kind: List
metadata:
